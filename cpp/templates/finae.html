<h1 id="sfinae-substitution-failure-is-not-an-error">SFINAE (Substitution Failure Is Not An Error)</h1>
<p>SFINAE is a principle in C++ template metaprogramming that allows the compiler to select the appropriate function or class when a specific template specialization fails during substitution. The term “substitution failure” refers to the process where the compiler tries to substitute template arguments into a function template or class template. If the substitution causes an error, the compiler won’t consider that specific specialization as a candidate and will continue searching for a valid one.</p>
<p>The key idea behind SFINAE is that if a substitution error occurs, it is silently ignored, and the compiler continues to explore other template specializations or overloads. This allows you to write more flexible and generic code, as it enables you to have multiple specializations for different scenarios.</p>
<h2 id="code-example">Code Example</h2>
<p>Here’s an example that demonstrates SFINAE in action:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#FF79C6">#include</span><span style="color:#E9F284"> &#x3C;</span><span style="color:#F1FA8C">iostream</span><span style="color:#E9F284">></span></span>
<span class="line"><span style="color:#FF79C6">#include</span><span style="color:#E9F284"> &#x3C;</span><span style="color:#F1FA8C">type_traits</span><span style="color:#E9F284">></span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">template</span><span style="color:#F8F8F2"> &#x3C;</span><span style="color:#FF79C6">typename</span><span style="color:#8BE9FD;font-style:italic"> T</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">typename</span><span style="color:#FF79C6"> =</span><span style="color:#F8F8F2"> void></span></span>
<span class="line"><span style="color:#FF79C6">struct</span><span style="color:#8BE9FD;font-style:italic"> foo_impl</span><span style="color:#F8F8F2"> {</span></span>
<span class="line"><span style="color:#FF79C6">    void</span><span style="color:#FF79C6"> operator</span><span style="color:#F8F8F2">()(</span><span style="color:#8BE9FD;font-style:italic">T</span><span style="color:#FFB86C;font-style:italic"> t</span><span style="color:#F8F8F2">) {</span></span>
<span class="line"><span style="color:#F8F8F2">        std</span><span style="color:#FF79C6">::</span><span style="color:#F8F8F2">cout </span><span style="color:#FF79C6">&#x3C;&#x3C;</span><span style="color:#E9F284"> "</span><span style="color:#F1FA8C">Called when T is not arithmetic</span><span style="color:#E9F284">"</span><span style="color:#FF79C6"> &#x3C;&#x3C;</span><span style="color:#F8F8F2"> std</span><span style="color:#FF79C6">::</span><span style="color:#F8F8F2">endl;</span></span>
<span class="line"><span style="color:#F8F8F2">    }</span></span>
<span class="line"><span style="color:#F8F8F2">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">template</span><span style="color:#F8F8F2"> &#x3C;</span><span style="color:#FF79C6">typename</span><span style="color:#8BE9FD;font-style:italic"> T</span><span style="color:#F8F8F2">></span></span>
<span class="line"><span style="color:#FF79C6">struct</span><span style="color:#8BE9FD;font-style:italic"> foo_impl</span><span style="color:#F8F8F2">&#x3C;</span><span style="color:#8BE9FD;font-style:italic">T</span><span style="color:#F8F8F2">, std</span><span style="color:#FF79C6">::</span><span style="color:#8BE9FD;font-style:italic">enable_if_t</span><span style="color:#F8F8F2">&#x3C;std</span><span style="color:#FF79C6">::</span><span style="color:#F8F8F2">is_arithmetic&#x3C;</span><span style="color:#8BE9FD;font-style:italic">T</span><span style="color:#F8F8F2">></span><span style="color:#FF79C6">::</span><span style="color:#8BE9FD;font-style:italic">value</span><span style="color:#F8F8F2">>> {</span></span>
<span class="line"><span style="color:#FF79C6">    void</span><span style="color:#FF79C6"> operator</span><span style="color:#F8F8F2">()(</span><span style="color:#8BE9FD;font-style:italic">T</span><span style="color:#FFB86C;font-style:italic"> t</span><span style="color:#F8F8F2">) {</span></span>
<span class="line"><span style="color:#F8F8F2">        std</span><span style="color:#FF79C6">::</span><span style="color:#F8F8F2">cout </span><span style="color:#FF79C6">&#x3C;&#x3C;</span><span style="color:#E9F284"> "</span><span style="color:#F1FA8C">Called when T is arithmetic</span><span style="color:#E9F284">"</span><span style="color:#FF79C6"> &#x3C;&#x3C;</span><span style="color:#F8F8F2"> std</span><span style="color:#FF79C6">::</span><span style="color:#F8F8F2">endl;</span></span>
<span class="line"><span style="color:#F8F8F2">    }</span></span>
<span class="line"><span style="color:#F8F8F2">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">template</span><span style="color:#F8F8F2"> &#x3C;</span><span style="color:#FF79C6">typename</span><span style="color:#8BE9FD;font-style:italic"> T</span><span style="color:#F8F8F2">></span></span>
<span class="line"><span style="color:#FF79C6">void</span><span style="color:#50FA7B"> foo</span><span style="color:#F8F8F2">(</span><span style="color:#8BE9FD;font-style:italic">T</span><span style="color:#FFB86C;font-style:italic"> t</span><span style="color:#F8F8F2">) {</span></span>
<span class="line"><span style="color:#50FA7B">    foo_impl</span><span style="color:#F8F8F2">&#x3C;</span><span style="color:#8BE9FD;font-style:italic">T</span><span style="color:#F8F8F2">>()(t);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">int</span><span style="color:#50FA7B"> main</span><span style="color:#F8F8F2">() {</span></span>
<span class="line"><span style="color:#FF79C6">    int</span><span style="color:#F8F8F2"> a </span><span style="color:#FF79C6">=</span><span style="color:#BD93F9"> 5</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#50FA7B">    foo</span><span style="color:#F8F8F2">(a);</span><span style="color:#6272A4"> // output: Called when T is arithmetic</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">    std</span><span style="color:#FF79C6">::</span><span style="color:#F8F8F2">string s </span><span style="color:#FF79C6">=</span><span style="color:#E9F284"> "</span><span style="color:#F1FA8C">example</span><span style="color:#E9F284">"</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#50FA7B">    foo</span><span style="color:#F8F8F2">(s);</span><span style="color:#6272A4"> // output: Called when T is not arithmetic</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>In this example, we define two <code>foo_impl</code> functions are specialized based on the boolean value of <code>std::is_arithmetic&#x3C;T></code>. The first one is enabled when <code>T</code> is an arithmetic type, while the second one is enabled when <code>T</code> is not an arithmetic type. The <code>foo</code> function then calls the appropriate <code>foo_impl</code> specialization based on the result of the type trait.</p>
<p>When calling <code>foo(a)</code> with an integer, the first specialization is selected, and when calling <code>foo(s)</code> with a string, the second specialization is selected. If there is no valid specialization, the code would fail to compile.</p>